[
  {
    "resource_id": "DynamoDB-A",
    "resource_type": "DynamoDB table",
    "detected_issue": "Severely over-provisioned capacity for very low traffic; unused GSIs; TTL disabled keeping session data indefinitely.",
    "reasoning": "Provisioned 1000 RCUs / 500 WCUs while the table receives <10 requests per minute (~0.17 rps), so most capacity is idle. Description states most secondary indexes are rarely queried, yet GSIs still incur write and storage costs. TTL is disabled, so old session items (and their GSI copies) persist and inflate storage costs.",
    "optimization_suggestion": "Switch billing mode to PAY_PER_REQUEST (on-demand) to pay only for actual reads/writes, or drastically reduce provisioned capacity and enable auto scaling; enable TTL on a session expiration attribute to automatically purge stale items; remove rarely used GSIs (e.g., UserEmailIndex, LastLoginIndex, RegionIndex) to cut write amplification and index storage; consider the DynamoDB Standard-IA table class given the low access rate if higher R/W prices remain acceptable."
  },
  {
    "resource_id": "DynamoDB-B",
    "resource_type": "DynamoDB table",
    "detected_issue": "Using on-demand for stable, high throughput results in premium per-request pricing.",
    "reasoning": "Configuration shows ON_DEMAND with sustained average ~400 reads/sec and ~250 writes/sec. For predictable, steady traffic, provisioned capacity is typically cheaper than on-demandâ€™s per-request rates.",
    "optimization_suggestion": "Migrate to PROVISIONED capacity with auto scaling on reads and writes; set target utilization (e.g., ~70%) and min/max capacity near observed averages and peaks; keep the Standard table class (Standard-IA is not suitable for high access)."
  },
  {
    "resource_id": "DynamoDB-C",
    "resource_type": "DynamoDB table",
    "detected_issue": "Under-provisioned without auto scaling for spiky traffic, causing throttling and costly retries.",
    "reasoning": "Provisioned at 50 RCUs / 10 WCUs while observed peaks reach ~500 reads/sec and ~200 writes/sec. Auto scaling is disabled, so bursts exceed capacity, trigger throttling, and induce retries that increase total request cost.",
    "optimization_suggestion": "Switch to PAY_PER_REQUEST to elastically handle unpredictable spikes and eliminate throttling-driven retries; alternatively, enable auto scaling for both table and the ActivityIndex GSI with max capacity set to cover peak (and reasonable min to control cost), and a target utilization policy to scale up during spikes."
  },
  {
    "resource_id": "DynamoDB-D",
    "resource_type": "DynamoDB table",
    "detected_issue": "High storage and backup costs for rarely accessed, long-retained data; unnecessary provisioned capacity.",
    "reasoning": "Table holds 200 GB of old analytics data kept indefinitely with TTL disabled, and PITR enabled which adds ongoing backup storage cost. Access is rare, yet capacity is provisioned at 200 RCUs / 100 WCUs, likely underutilized.",
    "optimization_suggestion": "Enable TTL to expire aged metrics/logs and shrink both table and backup footprint; consider switching PITR off and replacing with periodic on-demand backups (e.g., via AWS Backup) if point-in-time restore is not required; change billing mode to PAY_PER_REQUEST (or sharply reduce provisioned RCUs/WCUs with auto scaling) since access is infrequent; switch the table to the DynamoDB Standard-IA table class to reduce storage cost for cold data; optionally export historical data to S3 for cheaper retention and query with Athena, then delete it from DynamoDB."
  }
]